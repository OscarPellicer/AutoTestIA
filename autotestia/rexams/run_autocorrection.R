## Script to run auto-correction of exams using R/exams
## This script requires R and the exams, qpdf, optparse packages to be installed.

# Ensure optparse is available
if (!require("optparse")) {
  install.packages("optparse", repos = "http://cran.rstudio.com/")
}
library("optparse")

# Define command line options
option_list <- list(
  make_option(c("--all-scans-pdf"), type = "character", default = NULL,
              help = "Path to the single PDF containing all scanned exams (required if --split-pages is TRUE). [default %default]", metavar = "character"),
  make_option(c("--scans-dir"), type = "character", default = "scanned_pages",
              help = "Directory for individual scanned exam pages (input for nops_scan, output for splitting). [default %default]", metavar = "character"),
  make_option(c("--student-info-csv"), type = "character", default = NULL,
              help = "Path to the input CSV with student information (e.g., registration, name, ID). [default %default]", metavar = "character"),
  make_option(c("--solutions-rds"), type = "character", default = "output_exams/exam.rds",
              help = "Path to the exam.rds file generated by exams2nops. [default %default]", metavar = "character"),
  make_option(c("--output-basename"), type = "character", default = "correction_results/exam_results",
              help = "Basename for results files (e.g., 'dir/exam_results' -> 'dir/exam_results.csv'). [default %default]", metavar = "character"),
  make_option(c("--language"), type = "character", default = "en",
              help = "Language for nops_eval (e.g., 'es', 'en', 'ca'). [default %default]", metavar = "character"),
  make_option(c("--scan-thresholds"), type = "character", default = "0.04,0.42",
              help = "Comma-separated scan threshold pair (lower,upper), e.g., '0.04,0.42'. [default %default]", metavar = "character"),
  make_option(c("--partial"), action = "store_true", default = TRUE,
              help = "Enable partial scoring for schoice/mchoice questions. [default %default]"),
  make_option(c("--no-partial"), action = "store_false", dest = "partial",
              help = "Disable partial scoring."),
  make_option(c("--negative-points"), type = "double", default = -1/3,
              help = "Penalty for incorrect answers (negative value). [default %default]", metavar = "double"),
  make_option(c("--max-score"), type = "double", default = NULL,
              help = "Maximum raw score of the exam (e.g., 44), for scaling the final grade. Required if scaling. [default %default]", metavar = "double"),
  make_option(c("--scale-mark-to"), type = "double", default = 10,
              help = "Target score for scaling (e.g., 10). [default %default]", metavar = "double"),
  make_option(c("--split-pages"), action = "store_true", default = FALSE,
              help = "Enable PDF splitting of --all-scans-pdf into --scans-dir. [default %default]"),
  make_option(c("--force-split"), action = "store_true", default = FALSE,
              help = "Force overwrite of existing split PDF files if --split-pages is TRUE. [default %default]"),
  make_option(c("--processed-register-filename"), type="character", default="processed_student_register.csv",
              help="Filename for the processed student registration CSV, saved in the dirname of --output-basename. [default %default]", metavar="character"),
  make_option(c("--student-csv-id-col"), type="character", default="ID.Usuario",
              help="Column name for student unique ID in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-reg-col"), type="character", default="Número.de.Identificación",
              help="Column name for student registration number (on sheet) in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-name-col"), type="character", default="Nombre",
              help="Column name for student first name in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-surname-col"), type="character", default="Apellidos",
              help="Column name for student surname(s) in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-encoding"), type="character", default="UTF-8",
              help="Encoding for the student CSV file. [default %default]", metavar="character"),
  make_option(c("--registration-format"), type="character", default="%08s",
              help="Format string for student registration numbers (e.g., '%08s' for 8-char string padding). [default %default]", metavar="character")
)

opt_parser <- OptionParser(option_list = option_list)
opts <- parse_args(opt_parser)

# Load required packages, install if missing
if (!require("exams")) { install.packages("exams", repos = "http://cran.rstudio.com/") }
library("exams")

# Helper function to ensure directory exists
ensure_dir <- function(path) {
  if (!dir.exists(path)) {
    message("Creating directory: ", path)
    dir.create(path, recursive = TRUE, showWarnings = FALSE)
  }
}

# Ensure output directory for results exists
ensure_dir(dirname(opts$`output-basename`))

# --- 1. Split PDFs if requested ---
if (opts$`split-pages`) {
  if (!require("qpdf")) {
    install.packages("qpdf", repos = "http://cran.rstudio.com/")
  }
  library("qpdf")

  if (is.null(opts$`all-scans-pdf`)) {
    stop("--all-scans-pdf must be provided when --split-pages is TRUE.")
  }
  if (!file.exists(opts$`all-scans-pdf`)) {
    stop(sprintf("Input PDF for splitting '%s' not found.", opts$`all-scans-pdf`))
  }
  ensure_dir(opts$`scans-dir`)

  message(sprintf("Splitting PDF: %s into directory: %s", opts$`all-scans-pdf`, opts$`scans-dir`))
  
  num_pages <- qpdf::pdf_length(opts$`all-scans-pdf`)
  message(sprintf("Input PDF has %d pages.", num_pages))

  existing_files <- list.files(opts$`scans-dir`, pattern = "page_.*\\.pdf$", full.names = TRUE)
  if (length(existing_files) > 0) {
    if (opts$`force-split`) {
      message("Forcing overwrite: Removing existing split PDF files in output directory...")
      file.remove(existing_files)
    } else {
      message("Found existing split PDF files. Skipping split. Use --force-split to overwrite.")
      # Set split_pages to FALSE effectively if not forcing, to avoid issues later if nops_scan expects fresh split.
      # Or, we assume user wants to use existing files. For now, we just skip.
      # The nops_scan will run on whatever is in scans-dir.
    }
  }
  
  if (length(existing_files) == 0 || opts$`force-split`) {
      message(sprintf("Starting split of %d pages into %s...", num_pages, opts$`scans-dir`))
      for (page_num in 1:num_pages) {
        output_file <- file.path(opts$`scans-dir`, sprintf("page_%03d.pdf", page_num))
        qpdf::pdf_subset(opts$`all-scans-pdf`, pages = page_num, output = output_file)
        if (page_num %% 20 == 0 || page_num == num_pages) { # Progress message
            cat(sprintf("\rPage %d/%d processed.", page_num, num_pages))
        }
      }
      cat("\nPDF successfully split.\n")
  }
}

# --- 2. Scan Exam Sheets ---
if (!dir.exists(opts$`scans-dir`) || length(list.files(opts$`scans-dir`, pattern = "\\.pdf$")) == 0) {
  stop(sprintf("Scanned pages directory '%s' is empty, does not exist, or contains no PDF files. Split PDFs first or check path.", opts$`scans-dir`))
}
message(sprintf("Scanning exams from directory: %s", opts$`scans-dir`))
scan_threshold_parts <- as.numeric(strsplit(opts$`scan-thresholds`, ",")[[1]])
if (length(scan_threshold_parts) != 2 || any(is.na(scan_threshold_parts))) {
  stop("Invalid --scan-thresholds format. Expected 'lower,upper', e.g., '0.04,0.42'.")
}

# nops_scan saves its output (a zip file) in the current working directory *by default* if dir is relative.
# To ensure it goes into scans-dir or a predictable place, make scans-dir absolute or cd into it.
# For simplicity, let's assume nops_scan output zip will be in scans-dir if dir is relative.
# Or, better, capture its return value which is the path to the zip file.
original_wd <- getwd()
# Changing WD can be risky if paths are relative. Let's try to use absolute paths for nops_scan.
# nops_scan's 'dir' argument specifies where the images are. The output zip is created in the *current working directory*.
# This is a bit tricky. To control output location of the zip, we can cd.
# A safer way: nops_scan returns the path to the zip file. We can use that.
# The zip file will be created in the current working directory of the R process.
# Let's ensure that the `scans-dir` is where it looks for images.
# And the output zip will be caught by `scan_result_zip`.

# The output dir for the zip can be controlled by `exams_eval` if we set `exams.dir` option
# However, nops_scan itself writes to `getwd()`. Let's try to place it predictably.
# We'll make sure the target output directory for the scan zip is the same as where results go.
scan_output_dir <- dirname(opts$`output-basename`)
ensure_dir(scan_output_dir)

# nops_scan will create the zip in `scan_output_dir` if we `setwd` there first.
setwd(scan_output_dir)
scanned_exams_dir_abs <- normalizePath(file.path(original_wd, opts$`scans-dir`)) # Ensure absolute path for nops_scan images

message(paste("Running nops_scan. Output zip will be in:", getwd()))
scan_result_zip <- nops_scan(
  dir = scanned_exams_dir_abs, # Directory with PDF/PNG images
  threshold = scan_threshold_parts,
  verbose = TRUE,
  rotate = FALSE 
)
# scan_result_zip is now the path to the created zip file, relative to scan_output_dir (new getwd())
# Make it absolute for later use
scan_result_zip_abs <- normalizePath(scan_result_zip) # This should be absolute now
setwd(original_wd) # Return to original working directory

message(sprintf("Scan complete. Output zip: %s", scan_result_zip_abs))
if (!file.exists(scan_result_zip_abs)) {
    stop(sprintf("nops_scan seemed to complete, but ZIP file '%s' was not found.", scan_result_zip_abs))
}


# --- 3. Prepare Student Registration Data ---
if (is.null(opts$`student-info-csv`)) {
  stop("--student-info-csv must be provided.")
}
if (!file.exists(opts$`student-info-csv`)) {
  stop(sprintf("Student info CSV '%s' not found.", opts$`student-info-csv`))
}

message(sprintf("Processing student data from: %s", opts$`student-info-csv`))
raw_student_data <- read.csv(opts$`student-info-csv`, stringsAsFactors = FALSE, fileEncoding = opts$`student-csv-encoding`, strip.white=TRUE)

# Check for required columns
required_cols <- c(opts$`student-csv-id-col`, opts$`student-csv-reg-col`, opts$`student-csv-name-col`, opts$`student-csv-surname-col`)
missing_cols <- required_cols[!required_cols %in% names(raw_student_data)]
if (length(missing_cols) > 0) {
  stop(sprintf("Missing required columns in student CSV: %s. Check column name parameters.", paste(missing_cols, collapse=", ")))
}

processed_student_data <- data.frame(
  registration = sprintf(opts$`registration-format`, as.character(raw_student_data[[opts$`student-csv-reg-col`]])),
  name = paste(raw_student_data[[opts$`student-csv-name-col`]], raw_student_data[[opts$`student-csv-surname-col`]]),
  id = raw_student_data[[opts$`student-csv-id-col`]],
  stringsAsFactors = FALSE
)

processed_register_path <- file.path(dirname(opts$`output-basename`), opts$`processed-register-filename`)
write.table(
  processed_student_data,
  file = processed_register_path,
  sep = ";",
  row.names = FALSE,
  quote = FALSE,
  fileEncoding = "UTF-8" # Standardize to UTF-8 for nops_eval
)
message(sprintf("Processed student registration data saved to: %s", processed_register_path))

# --- 4. Evaluate Exams ---
if (!file.exists(opts$`solutions-rds`)) {
  stop(sprintf("Solutions RDS file '%s' not found.", opts$`solutions-rds`))
}

message(sprintf("Evaluating exams using solutions: %s", opts$`solutions-rds`))
message(sprintf("Scan data from: %s", scan_result_zip_abs)) # Use the absolute path
message(sprintf("Student register: %s", processed_register_path))

nops_eval(
  register = processed_register_path,
  solutions = opts$`solutions-rds`,
  scans = scan_result_zip_abs, # Use the absolute path to the scan zip
  results = opts$`output-basename`, # Basename for .csv and .rds files
  language = opts$language,
  eval = exams_eval(partial = opts$partial, negative = opts$`negative-points`, rule = "false") # rule="false" standard behavior
)
message(sprintf("Evaluation complete. Results files generated with basename: %s", opts$`output-basename`))

# --- 5. Recalculate and Scale Marks ---
results_csv_file <- paste0(opts$`output-basename`, ".csv")
if (file.exists(results_csv_file)) {
  exam_results_data <- read.csv(results_csv_file, sep = ";", stringsAsFactors = FALSE, fileEncoding = "UTF-8")
  
  if ("points" %in% names(exam_results_data)) {
    if (!is.null(opts$`max-score`) && !is.na(opts$`max-score`)) {
      exam_results_data$mark_scaled <- round(exam_results_data$points * opts$`scale-mark-to` / opts$`max-score`, 2)
      
      scaled_results_csv_file <- paste0(opts$`output-basename`, "_scaled_to_", opts$`scale-mark-to`, ".csv")
      write.csv(exam_results_data, scaled_results_csv_file, row.names = FALSE, quote = FALSE, fileEncoding = "UTF-8")
      message(sprintf("Scaled marks (to %s) saved to: %s", opts$`scale-mark-to`, scaled_results_csv_file))
    } else {
      message("Skipping mark scaling: --max-score not provided or is NA. Raw points are in the results CSV.")
    }
  } else {
    warning("'points' column not found in results CSV. Cannot scale marks.")
  }
} else {
  warning(sprintf("Results CSV file %s not found. Cannot scale marks.", results_csv_file))
}

message("Autocorrection script finished.")
