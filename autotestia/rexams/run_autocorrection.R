# Script to run auto-correction of exams using R/exams
# This script requires R and the exams, qpdf, optparse packages to be installed.

# Ensure optparse is available
if (!require("optparse")) {
  install.packages("optparse", repos = "http://cran.rstudio.com/")
}
library("optparse")

# Define command line options
option_list <- list(
  make_option(c("--all-scans-pdf"), type = "character", default = NULL,
              help = "Path to the single PDF containing all scanned exams (required if --split-pages is TRUE). [default %default]", metavar = "character"),
  make_option(c("--student-info-csv"), type = "character", default = NULL,
              help = "Path to the input CSV with student information (e.g., registration, name, ID). [default %default]", metavar = "character"),
  make_option(c("--solutions-rds"), type = "character", default = NULL, # User still provides this critical input
              help = "Path to the exam.rds file generated by exams2nops (e.g., by exams2nops or generate_exams.R). [default %default]", metavar = "character"),
  make_option(c("--output-path"), type = "character", default = "autotestia_exam_correction_output",
              help = "Main directory for all intermediate and final outputs. [default %default]", metavar = "character"),
  make_option(c("--language"), type = "character", default = "en",
              help = "Language for nops_eval (e.g., 'es', 'en', 'ca'). [default %default]", metavar = "character"),
  make_option(c("--scan-thresholds"), type = "character", default = "0.04,0.42",
              help = "Comma-separated scan threshold pair (lower,upper), e.g., '0.04,0.42'. [default %default]", metavar = "character"),
  make_option(c("--partial"), action = "store_true", default = TRUE,
              help = "Enable partial scoring for schoice/mchoice questions. [default %default]"),
  make_option(c("--no-partial"), action = "store_false", dest = "partial",
              help = "Disable partial scoring."),
  make_option(c("--negative-points"), type = "double", default = -1/3,
              help = "Penalty for incorrect answers (negative value). [default %default]", metavar = "double"),
  make_option(c("--max-score"), type = "double", default = NULL,
              help = "Maximum raw score of the exam (e.g., 44), for scaling the final grade. Required if scaling. [default %default]", metavar = "double"),
  make_option(c("--scale-mark-to"), type = "double", default = 10,
              help = "Target score for scaling (e.g., 10). [default %default]", metavar = "double"),
  make_option(c("--split-pages"), action = "store_true", default = FALSE,
              help = "Enable PDF splitting of --all-scans-pdf into a subdirectory of --output-path. [default %default]"),
  make_option(c("--force-split"), action = "store_true", default = FALSE,
              help = "Force overwrite of existing split PDF files if --split-pages is TRUE. [default %default]"),
  make_option(c("--student-csv-id-col"), type="character", default="ID.Usuario",
              help="Column name for student unique ID in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-reg-col"), type="character", default="Número.de.Identificación",
              help="Column name for student registration number (on sheet) in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-name-col"), type="character", default="Nombre",
              help="Column name for student first name in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-surname-col"), type="character", default="Apellidos",
              help="Column name for student surname(s) in --student-info-csv. [default %default]", metavar="character"),
  make_option(c("--student-csv-encoding"), type="character", default="UTF-8",
              help="Encoding for the student CSV file. [default %default]", metavar="character"),
  make_option(c("--registration-format"), type="character", default="%08s",
              help="Format string for student registration numbers (e.g., '%08s' for 8-char string padding). [default %default]", metavar="character"),
  make_option(c("--force-nops-scan"), action = "store_true", default = FALSE,
              help = "Force nops_scan to re-run even if its output ZIP exists. [default %default]"),
  make_option(c("--rotate-scans"), action = "store_true", default = FALSE,
              help = "Enable image rotation during nops_scan. Default is FALSE, assuming input PDFs are correctly oriented. [default %default]"),
  make_option(c("--custom-mark-thresholds"), type = "character", default = NULL,
              help = "Comma-separated percentage thresholds for custom marks (e.g., '0.1,0.2,...,1.0'). Values must be >0 and <=1, and strictly increasing. If not provided and --omit-nops-marks is FALSE, a default Spanish grading system is used (thresholds '0.099,0.199,...,0.949'). [default: Spanish system or none if omitting marks]", metavar = "character"),
  make_option(c("--custom-mark-labels"), type = "character", default = NULL,
              help = "Comma-separated labels for custom marks (e.g., 'Label1,Label2,...,Label11'). Must have one more label than thresholds. If not provided and --omit-nops-marks is FALSE, default Spanish word labels are used (e.g., 'Suspenso Muy Deficiente,...,Matrícula de Honor'). Required if --custom-mark-thresholds is specified by the user. [default: Spanish system or none if omitting marks]", metavar = "character"),
  make_option(c("--omit-nops-marks"), action="store_true", default=FALSE,
              help="Omit the calculation of categorical marks by nops_eval (e.g., 0-10 scale). The 'mark' column in nops_eval outputs will be NA, overriding any custom/default mark thresholds/labels for this step.")
)

opt_parser <- OptionParser(option_list = option_list)
opts <- parse_args(opt_parser)

# Ensure opts$`output-path` is scalar, as it drives many path constructions
if (length(opts$`output-path`) > 1) {
  warning(sprintf("Option --output-path resulted in a vector: %s. Using only the first element: '%s'",
                  paste(opts$`output-path`, collapse="', '"),
                  opts$`output-path`[1]))
  opts$`output-path` <- opts$`output-path`[1]
}

# Load required packages, install if missing
if (!require("exams")) { install.packages("exams", repos = "http://cran.rstudio.com/") }
library("exams")

# Helper function to ensure directory exists
ensure_dir <- function(path) {
  if (!dir.exists(path)) {
    message("Creating directory: ", path)
    dir.create(path, recursive = TRUE, showWarnings = FALSE)
  }
}

# Ensure base output directory exists
ensure_dir(opts$`output-path`)

# --- Derived Paths ---
# Directory for split PDF pages
derived_scans_dir <- file.path(opts$`output-path`, "scanned_pages")
# Basename for final nops_eval results (CSV, RDS)
derived_results_basename <- file.path(opts$`output-path`, "exam_corrected_results")
# Path for the processed student registration file
derived_processed_register_path <- file.path(opts$`output-path`, "processed_student_register.csv")


# --- 1. Split PDFs if requested ---
if (opts$`split-pages`) {
  if (!require("qpdf")) {
    install.packages("qpdf", repos = "http://cran.rstudio.com/")
  }
  library("qpdf")

  if (is.null(opts$`all-scans-pdf`)) {
    stop("--all-scans-pdf must be provided when --split-pages is TRUE.")
  }
  if (!file.exists(opts$`all-scans-pdf`)) {
    stop(sprintf("Input PDF for splitting '%s' not found.", opts$`all-scans-pdf`))
  }
  ensure_dir(derived_scans_dir) # Use derived path

  message(sprintf("Splitting PDF: %s into directory: %s", opts$`all-scans-pdf`, derived_scans_dir))

  num_pages <- qpdf::pdf_length(opts$`all-scans-pdf`)
  message(sprintf("Input PDF has %d pages.", num_pages))

  existing_files <- list.files(derived_scans_dir, pattern = "page_.*\\.pdf$", full.names = TRUE)
  if (length(existing_files) > 0) {
    if (opts$`force-split`) {
      message("Forcing overwrite: Removing existing split PDF files in output directory...")
      file.remove(existing_files)
    } else {
      message("Found existing split PDF files. Skipping split. Use --force-split to overwrite.")
    }
  }

  if (length(existing_files) == 0 || opts$`force-split`) {
      message(sprintf("Starting split of %d pages into %s...", num_pages, derived_scans_dir))
      for (page_num in 1:num_pages) {
        output_file <- file.path(derived_scans_dir, sprintf("page_%03d.pdf", page_num))
        qpdf::pdf_subset(opts$`all-scans-pdf`, pages = page_num, output = output_file)
        if (page_num %% 20 == 0 || page_num == num_pages) { # Progress message
            cat(sprintf("\rPage %d/%d processed.", page_num, num_pages))
        }
      }
      cat("\nPDF successfully split.\n")
  }
}

# --- 2. Scan Exam Sheets ---
# Input for nops_scan is the derived_scans_dir
if (!dir.exists(derived_scans_dir) || length(list.files(derived_scans_dir, pattern = "\\.pdf$")) == 0) {
  stop(sprintf("Scanned pages input directory '%s' is empty, does not exist, or contains no PDF files. Split PDFs first or check path.", derived_scans_dir))
}
message(sprintf("Source directory for nops_scan images: %s", derived_scans_dir))

scan_threshold_parts <- as.numeric(strsplit(opts$`scan-thresholds`, ",")[[1]])
if (length(scan_threshold_parts) != 2 || any(is.na(scan_threshold_parts))) {
  stop("Invalid --scan-thresholds format. Expected 'lower,upper', e.g., '0.04,0.42'.")
}

ensure_dir(derived_scans_dir) # This is opts$`output-path`

# Find the latest existing nops_scan zip file in derived_scans_dir
latest_scan_zip <- NULL
potential_zips <- list.files(
  path = derived_scans_dir, # Search in the main output path
  pattern = "^nops_scan_.*\\.zip$",
  full.names = TRUE
)

if (length(potential_zips) > 0) {
  file_infos <- file.info(potential_zips)
  latest_scan_zip <- potential_zips[order(file_infos$mtime, decreasing = TRUE)][1]
  latest_scan_zip <- normalizePath(latest_scan_zip, winslash = "/", mustWork = TRUE)
}

scan_result_zip_abs <- NULL # This will hold the path to the zip nops_eval will use

if (!is.null(latest_scan_zip) && !opts$`force-nops-scan`) {
  message(sprintf("Found existing, most recent scan data ZIP: %s. Skipping nops_scan.", latest_scan_zip))
  scan_result_zip_abs <- latest_scan_zip
} else {
  if (opts$`force-nops-scan` && !is.null(latest_scan_zip)) {
    message(sprintf("Forcing nops_scan. Existing scan ZIPs (like '%s') will be superseded by a new one.", latest_scan_zip))
  } else if (is.null(latest_scan_zip)) {
    message(sprintf("No existing nops_scan ZIP found in %s matching pattern '^nops_scan_.*\\.zip$'. Running nops_scan.", derived_scans_dir))
  }

  original_wd <- getwd()
  setwd(derived_scans_dir) # nops_scan writes output to current working directory

  # Input directory for nops_scan is derived_scans_dir, made absolute
  scanned_exams_input_dir_abs <- normalizePath(derived_scans_dir, winslash = "/", mustWork = TRUE)

  message(paste("Running nops_scan. Image source dir:", scanned_exams_input_dir_abs, ". Output zip will be created in:", getwd()))
  # Run nops_scan. Its direct return value can be unreliable if there are internal errors.
  nops_scan_return_value <- nops_scan(
    dir = scanned_exams_input_dir_abs, # Source of images
    threshold = scan_threshold_parts,
    verbose = TRUE,
    rotate = opts$`rotate-scans`
  )
  message(sprintf("nops_scan direct return value (for debugging, may not be the zip filename if errors occurred): %s", paste(nops_scan_return_value, collapse="; ")))

  # nops_scan creates its output ZIP in the current working directory (which is derived_scans_dir).
  # Search for the ZIP file nops_scan should have created.
  Sys.sleep(1) # Brief pause to help ensure file system has caught up

  created_zips_after_scan <- list.files(
    path = getwd(), # Current directory is derived_scans_dir
    pattern = "^nops_scan_.*\\.zip$",
    full.names = FALSE # Get basenames first
  )

  if (length(created_zips_after_scan) > 0) {
    # Sort by modification time to get the newest one, as nops_scan names them with timestamps
    file_infos_after_scan <- file.info(file.path(getwd(), created_zips_after_scan)) # Need full path for file.info if CWD changed
    latest_created_zip_basename <- created_zips_after_scan[order(file_infos_after_scan$mtime, decreasing = TRUE)][1]
    
    # Construct absolute path from the CWD of nops_scan and the found basename
    scan_result_zip_abs <- normalizePath(file.path(getwd(), latest_created_zip_basename), winslash = "/", mustWork = TRUE)
    message(sprintf("Identified nops_scan output ZIP in %s: %s", getwd(), scan_result_zip_abs))
  } else {
    # This is a critical failure if the ZIP wasn't created or found
    # It's important to change back WD before stopping, so we capture original_wd correctly
    setwd(original_wd) 
    stop(sprintf("nops_scan ran but no output ZIP (nops_scan_*.zip) was found in %s. Direct nops_scan return was: %s",
                 derived_scans_dir, paste(nops_scan_return_value, collapse="; ")))
  }

  setwd(original_wd) # Restore original working directory

  if (!file.exists(scan_result_zip_abs)) { # This check might now be redundant if the above logic works
      stop(sprintf("nops_scan seemed to complete, but its identified output ZIP file '%s' was not found.", scan_result_zip_abs))
  }
  message(sprintf("Scan processing complete. Identified output zip: %s", scan_result_zip_abs))
}

# --- 3.5 Run nops_fix ---
message(sprintf("If the scanning fails, try running nops_fix on scan_result_zip_abs on an R terminal: library(exams); nops_fix(\"%s\")", scan_result_zip_abs))
# nops_fix(scan_result_zip_abs)

# --- 3. Prepare Student Registration Data ---
if (is.null(opts$`student-info-csv`)) {
  stop("--student-info-csv must be provided.")
}
if (!file.exists(opts$`student-info-csv`)) {
  stop(sprintf("Student info CSV '%s' not found.", opts$`student-info-csv`))
}

message(sprintf("Processing student data from: %s", opts$`student-info-csv`))

# Determine colClasses to read registration ID as character
col_classes_vec <- NA # Default to NA (guess all types) if header reading fails
tryCatch({
    # Read just the header to get column names accurately as R sees them
    temp_data_header <- read.csv(opts$`student-info-csv`,
                                 nrows = 0, # nrows = 0 reads only header and determines column types
                                 header = TRUE,
                                 fileEncoding = opts$`student-csv-encoding`,
                                 check.names = FALSE) # Match how main data is read
    actual_col_names <- names(temp_data_header)
    
    col_classes_vec <- rep(NA_character_, length(actual_col_names)) # NA_character_ means default conversion
    names(col_classes_vec) <- actual_col_names
    
    if (opts$`student-csv-reg-col` %in% actual_col_names) {
        col_classes_vec[opts$`student-csv-reg-col`] <- "character" # Specify 'character' for the registration column
    } else {
        # This warning indicates a potential mismatch that will likely be caught by the 'missing_cols' check later.
        warning(sprintf("Specified student registration column ('%s') not found in the header of '%s'. Proceeding with default type guessing for this column.",
                        opts$`student-csv-reg-col`, opts$`student-info-csv`))
    }
}, error = function(e) {
    warning(sprintf("Could not reliably pre-read header of '%s' to set specific column types: %s. Proceeding with default type guessing for all columns.",
                    opts$`student-info-csv`, e$message))
    col_classes_vec <- NA # Fallback to default guessing for all columns if any error
})

raw_student_data <- read.csv(opts$`student-info-csv`,
                             stringsAsFactors = FALSE,
                             fileEncoding = opts$`student-csv-encoding`,
                             strip.white=TRUE,
                             check.names = FALSE,
                             colClasses = col_classes_vec) # Apply determined colClasses

required_cols <- c(opts$`student-csv-id-col`, opts$`student-csv-reg-col`, opts$`student-csv-name-col`, opts$`student-csv-surname-col`)
missing_cols <- required_cols[!required_cols %in% names(raw_student_data)]
if (length(missing_cols) > 0) {
  stop(sprintf("Missing required columns in student CSV: %s. CSV Header: %s. Check column name parameters (--student-csv-*-col).",
               paste(missing_cols, collapse=", "),
               paste(names(raw_student_data), collapse=", ")))
}

processed_student_data <- data.frame(
  # The column raw_student_data[[opts$`student-csv-reg-col`]] should now be character, preserving leading zeros.
  # The as.character() call is now redundant if colClasses worked, but harmless.
  registration = sprintf(opts$`registration-format`, raw_student_data[[opts$`student-csv-reg-col`]]),
  name = paste(raw_student_data[[opts$`student-csv-name-col`]], raw_student_data[[opts$`student-csv-surname-col`]]),
  id = raw_student_data[[opts$`student-csv-id-col`]],
  stringsAsFactors = FALSE
)

# Use derived_processed_register_path
write.table(
  processed_student_data,
  file = derived_processed_register_path,
  sep = ";",
  row.names = FALSE,
  quote = FALSE,
  fileEncoding = "UTF-8"
)
message(sprintf("Processed student registration data saved to: %s", derived_processed_register_path))

# --- 4. Evaluate Exams ---
if (is.null(opts$`solutions-rds`)) { # Check if solutions RDS is provided
    stop("--solutions-rds must be provided (path to the exam.rds file).")
}
if (!file.exists(opts$`solutions-rds`)) {
  stop(sprintf("Solutions RDS file '%s' not found.", opts$`solutions-rds`))
}

message(sprintf("Evaluating exams using solutions: %s", opts$`solutions-rds`))
message(sprintf("Scan data from: %s", scan_result_zip_abs))
message(sprintf("Student register: %s", derived_processed_register_path))

# --- Store current working directory and set new one for nops_eval output ---
original_wd_for_eval <- getwd()
output_dir_for_eval <- opts$`output-path` # This should be an absolute path to the desired output directory

# Ensure the output directory for nops_eval exists
ensure_dir(output_dir_for_eval)

setwd(output_dir_for_eval)
message(sprintf("Temporarily changed working directory for nops_eval to: %s", getwd()))

# Use only the basename for the results argument, nops_eval will create files in the current WD
results_file_basename_only <- "exam_corrected_results"

# --- Prepare mark and labels arguments for nops_eval ---
# Default Spanish grading system (word labels, precise 0-10 point equivalent thresholds)
default_spanish_thresholds_str <- "0.499,0.599,0.699,0.899,0.949"
default_spanish_labels_str <- "\"Suspenso\",\"Aprobado\",\"Bien\",\"Notable\",\"Sobresaliente\",\"Matrícula de Honor\""

nops_mark_arg <- NULL
nops_labels_arg <- NULL

if (opts$`omit-nops-marks`) {
  message("Omitting categorical marks from nops_eval as per --omit-nops-marks. 'mark' column in nops_eval outputs will be NA.")
  # nops_mark_arg and nops_labels_arg remain NULL
} else {
  current_thresholds_str <- opts$`custom-mark-thresholds`
  current_labels_str <- opts$`custom-mark-labels`

  if (is.null(current_thresholds_str) && is.null(current_labels_str)) {
    message("Using default Spanish grading system for nops_eval marks.")
    current_thresholds_str <- default_spanish_thresholds_str
    current_labels_str <- default_spanish_labels_str
  } else if (is.null(current_thresholds_str) || is.null(current_labels_str)) {
    stop("--custom-mark-thresholds and --custom-mark-labels must both be provided if one is set by the user and --omit-nops-marks is FALSE.")
  } else {
     message("Using user-provided custom mark thresholds and labels for nops_eval.")
  }

  nops_mark_arg_str <- trimws(strsplit(current_thresholds_str, ",")[[1]])
  nops_mark_arg <- as.numeric(nops_mark_arg_str)
  
  if (any(is.na(nops_mark_arg)) || any(nops_mark_arg <= 0) || any(nops_mark_arg > 1)) {
    stop("Invalid mark thresholds. Values must be numeric, > 0 and <= 1.")
  }
  # Check for strictly increasing order
  if (length(nops_mark_arg) > 1 && any(diff(nops_mark_arg) <= 0)) {
      stop("Mark thresholds must be strictly increasing (e.g., 0.5,0.6,0.7 not 0.5,0.7,0.6).")
  }

  nops_labels_arg_str <- trimws(strsplit(current_labels_str, ",")[[1]])
  nops_labels_arg <- nops_labels_arg_str # Keep as character

  if (length(nops_labels_arg) != (length(nops_mark_arg) + 1)) {
    stop(sprintf("Number of mark labels (%d) must be one greater than the number of mark thresholds (%d). Provided thresholds: '%s', labels: '%s'.",
                 length(nops_labels_arg), length(nops_mark_arg),
                 current_thresholds_str, current_labels_str))
  }
  message(sprintf("nops_eval will use mark thresholds: [%s] and labels: [%s].",
                  paste(nops_mark_arg, collapse=", "), paste(nops_labels_arg, collapse=", ")))
}

nops_eval(
  register = derived_processed_register_path, # This should be an absolute path
  solutions = opts$`solutions-rds`,          # This should be an absolute path
  scans = scan_result_zip_abs,               # This should be an absolute path
  results = results_file_basename_only,      # Pass only the basename
  language = opts$language,
  eval = exams_eval(partial = opts$partial, negative = opts$`negative-points`, rule = "false"),
  mark = nops_mark_arg,
  labels = nops_labels_arg,
  interactive = FALSE # Explicitly set to FALSE for non-interactive script execution
)

# --- Restore original working directory ---
setwd(original_wd_for_eval)
message(sprintf("Restored original working directory to: %s", getwd()))

# Construct the full path to the CSV file for subsequent scaling, now that we know where it was created.
results_csv_file <- file.path(output_dir_for_eval, paste0(results_file_basename_only, ".csv"))

message(sprintf("Evaluation complete. Results files should be in: %s with basename: %s", output_dir_for_eval, results_file_basename_only))

# --- 5. Recalculate and Scale Marks ---
if (file.exists(results_csv_file)) {
  exam_results_data <- read.csv(results_csv_file, sep = ";", stringsAsFactors = FALSE, fileEncoding = "UTF-8")

  if ("points" %in% names(exam_results_data)) {
    if (!is.null(opts$`max-score`) && !is.na(opts$`max-score`)) {
      exam_results_data$mark_scaled <- round(exam_results_data$points * opts$`scale-mark-to` / opts$`max-score`, 2)

      # Scaled results will also be in output_dir_for_eval
      scaled_results_csv_file <- file.path(output_dir_for_eval, paste0(results_file_basename_only, "_scaled_to_", opts$`scale-mark-to`, ".csv"))
      write.csv(exam_results_data, scaled_results_csv_file, row.names = FALSE, quote = FALSE, fileEncoding = "UTF-8")
      message(sprintf("Scaled marks (to %s) saved to: %s", opts$`scale-mark-to`, scaled_results_csv_file))
    } else {
      message("Skipping mark scaling: --max-score not provided or is NA. Raw points are in the results CSV.")
    }
  } else {
    warning("'points' column not found in results CSV. Cannot scale marks.")
  }
} else {
  warning(sprintf("Results CSV file %s not found. Cannot scale marks.", results_csv_file))
}

message("Autocorrection script finished.")

# Ensure the .lintr file has a newline at the end for the linter
# linters: linters_with_defaults(line_length_linter=NULL)

# For pattern = "^nops_scan_.*\\.zip$"
# This regex means:
# ^            - start of the string
# nops_scan_   - literal string "nops_scan_"
# .*           - any character (.), zero or more times (*)
# \\.          - a literal dot (escaped with \\ in R strings)
# zip$         - the literal string "zip" at the end of the string ($)
