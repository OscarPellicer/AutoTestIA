question_id	source_material	image_reference	generated_text	generated_answers_json	generated_eval_difficulty	generated_eval_pedagogy	generated_eval_clarity	generated_eval_distractors	generated_eval_comments	generated_eval_guessed_correctly	reviewed_text	reviewed_answers_json	reviewed_eval_difficulty	reviewed_eval_pedagogy	reviewed_eval_clarity	reviewed_eval_distractors	reviewed_eval_comments	reviewed_eval_guessed_correctly	final_text	final_answers_json	changes_gen_rev_status	changes_gen_rev_lev_question	changes_gen_rev_lev_answers	changes_gen_rev_rel_lev_question	changes_gen_rev_rel_lev_answers	changes_rev_man_status	changes_rev_man_lev_question	changes_rev_man_lev_answers	changes_rev_man_rel_lev_question	changes_rev_man_rel_lev_answers
custom_76105294	custom_instructions		¿Cuál es la salida del siguiente *script* de Python que utiliza un **decorador**? `def mi_decorador(func): def wrapper(): print('Antes de la función.') func() print('Después de la función.') return wrapper @mi_decorador def di_whee(): print('¡Whee!') di_whee()`	"{""correct"": ""Imprime 'Antes de la función.', luego '¡Whee!', y finalmente 'Después de la función.'"", ""distractors"": [""Imprime solo '¡Whee!'"", ""Imprime '¡Whee!', luego 'Antes de la función.', y finalmente 'Después de la función.'"", ""Lanza un `TypeError` porque el decorador se aplica incorrectamente.""], ""explanation"": """"}"	0.5	0.9	0.9	0.8	The question effectively assesses understanding of Python decorators, with clear options and plausible distractors regarding the execution flow.	True	¿Cuál es la salida del siguiente *script* de Python que utiliza un **decorador**? `def mi_decorador(func): def wrapper(): print('Antes de la función.') func() print('Después de la función.') return wrapper @mi_decorador def di_whee(): print('¡Whee!') di_whee()`	"{""correct"": ""Imprime 'Antes de la función.', luego '¡Whee!', y después 'Después de la función.'"", ""distractors"": [""Imprime solamente '¡Whee!'"", ""Imprime '¡Whee!', luego 'Antes de la función.', y después 'Después de la función.'"", ""Lanza un `TypeError` cuando se ejecuta el código del decorador""], ""explanation"": """"}"	0.5	0.9	0.9	0.8	This question effectively assesses understanding of Python decorators, with clear options and plausible distractors that test common misconceptions about their execution flow.	True			modified	0	62	0.0000	0.2375					
custom_12452655	custom_instructions		Al calcular la suma de los cuadrados de los primeros *N* números usando la fórmula $S_N = \sum_{i=0}^{N-1} i^2$, si *N* es un número muy grande, ¿cuál es la **diferencia principal** en el uso de memoria entre `sum([i*i for i in range(N)])` y `sum(i*i for i in range(N))`?	"{""correct"": ""La expresión generadora `(i*i for i in range(N))` consume mucha menos memoria porque genera los valores uno por uno, a medida que se necesitan."", ""distractors"": [""La comprensión de lista `[i*i for i in range(N)]` es más eficiente en memoria porque pre-asigna el espacio completo para la lista."", ""No hay ninguna diferencia significativa en el uso de memoria; el intérprete de Python optimiza ambas para que se comporten de manera idéntica."", ""La expresión generadora `(i*i for i in range(N))` es siempre computacionalmente más rápida, a costa de un mayor uso de memoria.""], ""explanation"": """"}"	0.5	0.9	0.9	0.8	The question effectively assesses understanding of generator expressions versus list comprehensions in Python, with plausible distractors, though some might find the nuance slightly challenging.	True	Al calcular la suma de los cuadrados de los primeros *N* números usando la fórmula $S_N = \sum_{i=0}^{N-1} i^2$, si *N* es un número muy grande, ¿cuál es la **diferencia principal** en el uso de memoria entre `sum([i*i for i in range(N)])` y `sum(i*i for i in range(N))`?	"{""correct"": ""La expresión generadora `(i*i for i in range(N))` consume mucha menos memoria porque genera los valores uno por uno, a medida que se necesitan"", ""distractors"": [""La comprensión de lista `[i*i for i in range(N)]` es más eficiente en memoria porque asigna el espacio completo para la lista al inicio"", ""No hay una diferencia significativa en el uso de memoria; el intérprete de Python optimiza ambas para que se comporten de manera similar"", ""La expresión generadora `(i*i for i in range(N))` es a menudo computacionalmente más rápida, lo que podría implicar un mayor uso de memoria""], ""explanation"": """"}"	0.5	0.9	0.9	0.8	This question effectively assesses a core Python concept (list comprehensions vs. generator expressions for memory optimization) with clear options and plausible distractors, making it of high pedagogical value for university students.	True			modified	0	52	0.0000	0.0954					
image_05270722	Image: image.jpg	E:\AutotestIA\AutoTestIA\media\image.jpg	Si estuvieras modelando los datos del perro de la imagen en Python usando un diccionario, ¿cuál de las siguientes opciones de `código` sería la representación más **precisa**? Ten en cuenta que la *felicidad* del perro parece alta.	"{""correct"": ""`datos_perro = {'raza': 'Pomerania', 'color': 'crema', 'en_correa': True, 'nivel_felicidad': $ \frac{9}{10} $}`"", ""distractors"": [""`datos_perro = {'raza': 'Samoyedo', 'color': 'blanco', 'en_correa': True, 'nivel_felicidad': 0.7}`"", ""`datos_perro = {'raza': 'Pomerania', 'color': 'negro', 'en_correa': False, 'nivel_felicidad': 0.5}`"", ""`datos_perro = {'raza': 'Spitz enano', 'color': 'crema', 'en_correa': False, 'nivel_felicidad': 0.2}`""], ""explanation"": """"}"	0.3	0.7	0.9	0.5	The question is clear and assesses basic Python dictionary usage, but the visual input requirement makes direct evaluation challenging, and some distractors are easily identifiable as incorrect based on the descriptive text.	True	Si estuvieras modelando los datos de un perro en Python usando un diccionario, ¿cuál de las siguientes opciones de código sería la representación más precisa, considerando que su felicidad parece alta y que las razas 'Pomerania' y 'Spitz enano' son la misma?	"{""correct"": ""`datos_perro = {'raza': 'Pomerania', 'color': 'crema', 'en_correa': True, 'nivel_felicidad': 0.9}`"", ""distractors"": [""`datos_perro = {'raza': 'Samoyedo', 'color': 'blanco', 'en_correa': True, 'nivel_felicidad': 0.7}`"", ""`datos_perro = {'raza': 'Pomerania', 'color': 'negro', 'en_correa': False, 'nivel_felicidad': 0.5}`"", ""`datos_perro = {'raza': 'Spitz enano', 'color': 'crema', 'en_correa': False, 'nivel_felicidad': 0.2}`""], ""explanation"": """"}"	0.5	0.8	0.9	0.7	The question effectively assesses dictionary usage and conditional interpretation in Python, with clear instructions and plausible distractors, though one distractor (Spitz enano) directly contradicts a stated premise, slightly reducing its overall strength.	True			modified	95	14	0.4113	0.0341					
